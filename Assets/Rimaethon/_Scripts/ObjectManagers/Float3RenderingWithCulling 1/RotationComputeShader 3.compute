#pragma kernel function

RWStructuredBuffer<float3> VertexPositionsOutput;
StructuredBuffer<float3> SpawnPositions;
StructuredBuffer<float3> VertexPositionsInput;
float rotY;
float rotX;
float rotZ;
int vertexCount;

[numthreads(32,1,1)]
void function(uint3 id : SV_DispatchThreadID)
{
    
    const int meshIndex = id.x * vertexCount;
    const float angleY = radians(rotY);
    const float angleX = radians(rotX);
    const float angleZ = radians(rotZ);

    const float3x3 rotationMatrixY = float3x3(
        cos(angleY), 0, sin(angleY),
        0, 1, 0,
        -sin(angleY), 0, cos(angleY)
    );

    const float3x3 rotationMatrixX = float3x3(
        1, 0, 0,
        0, cos(angleX), -sin(angleX),
        0, sin(angleX), cos(angleX)
    );

    const float3x3 rotationMatrixZ = float3x3(
        cos(angleZ), -sin(angleZ), 0,
        sin(angleZ), cos(angleZ), 0,
        0, 0, 1
    );

    float3x3 finalRotationMatrix = mul(rotationMatrixZ, mul(rotationMatrixX, rotationMatrixY));

    const float4x4 myMatrix = float4x4(
        finalRotationMatrix[0].x, finalRotationMatrix[0].y, finalRotationMatrix[0].z, SpawnPositions[id.x].x,
        finalRotationMatrix[1].x, finalRotationMatrix[1].y, finalRotationMatrix[1].z, SpawnPositions[id.x].y,
        finalRotationMatrix[2].x, finalRotationMatrix[2].y, finalRotationMatrix[2].z, SpawnPositions[id.x].z,
        0.0, 0.0, 0.0, 1.0
    );
   
    for (int i = 0; i < vertexCount; ++i)
    {
        VertexPositionsOutput[meshIndex+i] =  mul(myMatrix, float4(VertexPositionsInput[i],1)).xyz;

    }

    
}




